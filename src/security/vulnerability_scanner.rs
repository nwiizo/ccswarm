use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use std::process::Command;
use tokio::fs;
use tracing::{debug, info};

/// Vulnerability scanner for detecting known vulnerabilities in dependencies
pub struct VulnerabilityScanner {
    /// Cache of vulnerability database
    vuln_cache: HashMap<String, Vec<Vulnerability>>,
    
    /// Scanner configuration
    config: ScannerConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScannerConfig {
    /// Whether to update vulnerability database automatically
    pub auto_update_db: bool,
    
    /// Timeout for vulnerability checks (seconds)
    pub timeout_seconds: u64,
    
    /// Minimum severity to report
    pub min_severity: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// CVE identifier
    pub cve_id: String,
    
    /// Package name
    pub package_name: String,
    
    /// Affected version
    pub affected_version: String,
    
    /// Vulnerability severity (LOW, MEDIUM, HIGH, CRITICAL)
    pub severity: String,
    
    /// Description of the vulnerability
    pub description: String,
    
    /// Fixed version (if available)
    pub fixed_version: Option<String>,
    
    /// CVSS score
    pub cvss_score: Option<f64>,
    
    /// Source of vulnerability information
    pub source: String,
    
    /// References for more information
    pub references: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DependencyInfo {
    /// Package name
    pub name: String,
    
    /// Current version
    pub version: String,
    
    /// Package manager (npm, cargo, pip, etc.)
    pub package_manager: String,
    
    /// Whether it's a direct dependency
    pub is_direct: bool,
}

impl Default for ScannerConfig {
    fn default() -> Self {
        Self {
            auto_update_db: true,
            timeout_seconds: 30,
            min_severity: "MEDIUM".to_string(),
        }
    }
}

impl VulnerabilityScanner {
    /// Create a new vulnerability scanner
    pub async fn new() -> Result<Self> {
        Self::with_config(ScannerConfig::default()).await
    }

    /// Create a vulnerability scanner with custom configuration
    pub async fn with_config(config: ScannerConfig) -> Result<Self> {
        let mut scanner = Self {
            vuln_cache: HashMap::new(),
            config,
        };

        // Initialize vulnerability database if auto-update is enabled
        if scanner.config.auto_update_db {
            scanner.update_vulnerability_database().await?;
        }

        Ok(scanner)
    }

    /// Scan dependencies for vulnerabilities
    pub async fn scan_dependencies(&self, project_path: &Path) -> Result<Vec<Vulnerability>> {
        info!("Scanning dependencies for vulnerabilities in: {}", project_path.display());
        
        let mut all_vulnerabilities = Vec::new();

        // Scan different package managers
        if let Ok(vulnerabilities) = self.scan_npm_dependencies(project_path).await {
            all_vulnerabilities.extend(vulnerabilities);
        }

        if let Ok(vulnerabilities) = self.scan_cargo_dependencies(project_path).await {
            all_vulnerabilities.extend(vulnerabilities);
        }

        if let Ok(vulnerabilities) = self.scan_pip_dependencies(project_path).await {
            all_vulnerabilities.extend(vulnerabilities);
        }

        if let Ok(vulnerabilities) = self.scan_composer_dependencies(project_path).await {
            all_vulnerabilities.extend(vulnerabilities);
        }

        // Filter by minimum severity
        let filtered_vulnerabilities: Vec<Vulnerability> = all_vulnerabilities
            .into_iter()
            .filter(|v| self.meets_severity_threshold(&v.severity))
            .collect();

        info!("Found {} vulnerabilities meeting severity threshold", filtered_vulnerabilities.len());
        
        Ok(filtered_vulnerabilities)
    }

    /// Scan npm/yarn dependencies
    async fn scan_npm_dependencies(&self, project_path: &Path) -> Result<Vec<Vulnerability>> {
        let package_json_path = project_path.join("package.json");
        if !package_json_path.exists() {
            return Ok(Vec::new());
        }

        debug!("Scanning npm dependencies");

        let mut vulnerabilities = Vec::new();

        // Try npm audit first
        if let Ok(output) = self.run_npm_audit(project_path).await {
            vulnerabilities.extend(self.parse_npm_audit_output(&output)?);
        }

        // Fallback to manual dependency check
        if vulnerabilities.is_empty() {
            let dependencies = self.extract_npm_dependencies(project_path).await?;
            for dep in dependencies {
                if let Some(vulns) = self.vuln_cache.get(&dep.name) {
                    let matching_vulns: Vec<_> = vulns
                        .iter()
                        .filter(|v| self.version_matches(&dep.version, &v.affected_version))
                        .cloned()
                        .collect();
                    vulnerabilities.extend(matching_vulns);
                }
            }
        }

        Ok(vulnerabilities)
    }

    /// Run npm audit command
    async fn run_npm_audit(&self, project_path: &Path) -> Result<String> {
        let output = Command::new("npm")
            .args(&["audit", "--json", "--production"])
            .current_dir(project_path)
            .output()
            .context("Failed to run npm audit")?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            // npm audit returns non-zero status when vulnerabilities are found
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        }
    }

    /// Parse npm audit JSON output
    fn parse_npm_audit_output(&self, output: &str) -> Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();

        // Parse npm audit JSON output
        if let Ok(audit_result) = serde_json::from_str::<serde_json::Value>(output) {
            if let Some(advisories) = audit_result.get("advisories").and_then(|v| v.as_object()) {
                for (_, advisory) in advisories {
                    if let Some(vuln) = self.parse_npm_advisory(advisory) {
                        vulnerabilities.push(vuln);
                    }
                }
            }
        }

        Ok(vulnerabilities)
    }

    /// Parse individual npm advisory
    fn parse_npm_advisory(&self, advisory: &serde_json::Value) -> Option<Vulnerability> {
        let cve_id = advisory.get("cves")
            .and_then(|v| v.as_array())
            .and_then(|arr| arr.first())
            .and_then(|v| v.as_str())
            .unwrap_or("N/A")
            .to_string();

        let package_name = advisory.get("module_name")
            .and_then(|v| v.as_str())?
            .to_string();

        let severity = advisory.get("severity")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_uppercase();

        let description = advisory.get("title")
            .and_then(|v| v.as_str())
            .unwrap_or("No description available")
            .to_string();

        let affected_version = advisory.get("vulnerable_versions")
            .and_then(|v| v.as_str())
            .unwrap_or("*")
            .to_string();

        let fixed_version = advisory.get("patched_versions")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let references = advisory.get("references")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str())
                    .map(|s| s.to_string())
                    .collect()
            })
            .unwrap_or_default();

        Some(Vulnerability {
            cve_id,
            package_name,
            affected_version,
            severity,
            description,
            fixed_version,
            cvss_score: None,
            source: "npm audit".to_string(),
            references,
        })
    }

    /// Extract npm dependencies from package.json
    async fn extract_npm_dependencies(&self, project_path: &Path) -> Result<Vec<DependencyInfo>> {
        let package_json_path = project_path.join("package.json");
        let content = fs::read_to_string(&package_json_path).await?;
        let package_json: serde_json::Value = serde_json::from_str(&content)?;

        let mut dependencies = Vec::new();

        // Direct dependencies
        if let Some(deps) = package_json.get("dependencies").and_then(|v| v.as_object()) {
            for (name, version) in deps {
                dependencies.push(DependencyInfo {
                    name: name.clone(),
                    version: version.as_str().unwrap_or("*").to_string(),
                    package_manager: "npm".to_string(),
                    is_direct: true,
                });
            }
        }

        // Dev dependencies
        if let Some(dev_deps) = package_json.get("devDependencies").and_then(|v| v.as_object()) {
            for (name, version) in dev_deps {
                dependencies.push(DependencyInfo {
                    name: name.clone(),
                    version: version.as_str().unwrap_or("*").to_string(),
                    package_manager: "npm".to_string(),
                    is_direct: true,
                });
            }
        }

        Ok(dependencies)
    }

    /// Scan Cargo dependencies
    async fn scan_cargo_dependencies(&self, project_path: &Path) -> Result<Vec<Vulnerability>> {
        let cargo_toml_path = project_path.join("Cargo.toml");
        if !cargo_toml_path.exists() {
            return Ok(Vec::new());
        }

        debug!("Scanning Cargo dependencies");

        // Try cargo audit first
        if let Ok(output) = self.run_cargo_audit(project_path).await {
            return self.parse_cargo_audit_output(&output);
        }

        // Fallback to manual dependency check
        let dependencies = self.extract_cargo_dependencies(project_path).await?;
        let mut vulnerabilities = Vec::new();

        for dep in dependencies {
            if let Some(vulns) = self.vuln_cache.get(&dep.name) {
                let matching_vulns: Vec<_> = vulns
                    .iter()
                    .filter(|v| self.version_matches(&dep.version, &v.affected_version))
                    .cloned()
                    .collect();
                vulnerabilities.extend(matching_vulns);
            }
        }

        Ok(vulnerabilities)
    }

    /// Run cargo audit command
    async fn run_cargo_audit(&self, project_path: &Path) -> Result<String> {
        let output = Command::new("cargo")
            .args(&["audit", "--json"])
            .current_dir(project_path)
            .output()
            .context("Failed to run cargo audit")?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Ok(String::from_utf8_lossy(&output.stderr).to_string())
        }
    }

    /// Parse cargo audit output
    fn parse_cargo_audit_output(&self, output: &str) -> Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();

        for line in output.lines() {
            if let Ok(advisory) = serde_json::from_str::<serde_json::Value>(line) {
                if let Some(vuln) = self.parse_cargo_advisory(&advisory) {
                    vulnerabilities.push(vuln);
                }
            }
        }

        Ok(vulnerabilities)
    }

    /// Parse cargo advisory
    fn parse_cargo_advisory(&self, advisory: &serde_json::Value) -> Option<Vulnerability> {
        let cve_id = advisory.get("advisory")
            .and_then(|a| a.get("id"))
            .and_then(|v| v.as_str())?
            .to_string();

        let package_name = advisory.get("package")
            .and_then(|p| p.get("name"))
            .and_then(|v| v.as_str())?
            .to_string();

        let severity = advisory.get("advisory")
            .and_then(|a| a.get("severity"))
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_uppercase();

        let description = advisory.get("advisory")
            .and_then(|a| a.get("title"))
            .and_then(|v| v.as_str())
            .unwrap_or("No description available")
            .to_string();

        let affected_version = advisory.get("package")
            .and_then(|p| p.get("version"))
            .and_then(|v| v.as_str())
            .unwrap_or("*")
            .to_string();

        Some(Vulnerability {
            cve_id,
            package_name,
            affected_version,
            severity,
            description,
            fixed_version: None,
            cvss_score: None,
            source: "cargo audit".to_string(),
            references: Vec::new(),
        })
    }

    /// Extract Cargo dependencies
    async fn extract_cargo_dependencies(&self, project_path: &Path) -> Result<Vec<DependencyInfo>> {
        let cargo_toml_path = project_path.join("Cargo.toml");
        let content = fs::read_to_string(&cargo_toml_path).await?;
        
        // Simple TOML parsing - in production, you'd use a proper TOML parser
        let mut dependencies = Vec::new();
        let mut in_dependencies = false;
        
        for line in content.lines() {
            let line = line.trim();
            
            if line == "[dependencies]" {
                in_dependencies = true;
                continue;
            } else if line.starts_with('[') {
                in_dependencies = false;
                continue;
            }
            
            if in_dependencies && line.contains('=') {
                let parts: Vec<&str> = line.split('=').collect();
                if parts.len() == 2 {
                    let name = parts[0].trim().trim_matches('"');
                    let version = parts[1].trim().trim_matches('"');
                    
                    dependencies.push(DependencyInfo {
                        name: name.to_string(),
                        version: version.to_string(),
                        package_manager: "cargo".to_string(),
                        is_direct: true,
                    });
                }
            }
        }
        
        Ok(dependencies)
    }

    /// Scan pip dependencies (basic implementation)
    async fn scan_pip_dependencies(&self, project_path: &Path) -> Result<Vec<Vulnerability>> {
        let requirements_path = project_path.join("requirements.txt");
        if !requirements_path.exists() {
            return Ok(Vec::new());
        }

        debug!("Scanning pip dependencies");
        
        // In a full implementation, you would use tools like safety or pip-audit
        Ok(Vec::new())
    }

    /// Scan composer dependencies (basic implementation)
    async fn scan_composer_dependencies(&self, project_path: &Path) -> Result<Vec<Vulnerability>> {
        let composer_json_path = project_path.join("composer.json");
        if !composer_json_path.exists() {
            return Ok(Vec::new());
        }

        debug!("Scanning composer dependencies");
        
        // In a full implementation, you would integrate with SensioLabs Security Checker
        Ok(Vec::new())
    }

    /// Check if severity meets the minimum threshold
    fn meets_severity_threshold(&self, severity: &str) -> bool {
        let severity_levels = ["LOW", "MEDIUM", "HIGH", "CRITICAL"];
        
        let min_index = severity_levels.iter()
            .position(|&s| s == self.config.min_severity.as_str())
            .unwrap_or(1); // Default to MEDIUM
        
        let vuln_index = severity_levels.iter()
            .position(|&s| s == severity)
            .unwrap_or(0);
        
        vuln_index >= min_index
    }

    /// Check if a version matches a vulnerability pattern
    fn version_matches(&self, current_version: &str, affected_pattern: &str) -> bool {
        // Simplified version matching - in production, use semver crate
        if affected_pattern == "*" || affected_pattern.is_empty() {
            return true;
        }
        
        if affected_pattern.contains(">=") {
            // Handle version ranges
            let min_version = affected_pattern.replace(">=", "").trim().to_string();
            return current_version >= min_version.as_str();
        }
        
        if affected_pattern.contains("<") {
            let max_version = affected_pattern.replace("<", "").trim().to_string();
            return current_version < max_version.as_str();
        }
        
        // Exact match
        current_version == affected_pattern
    }

    /// Update vulnerability database
    async fn update_vulnerability_database(&mut self) -> Result<()> {
        info!("Updating vulnerability database");
        
        // In a full implementation, this would fetch from:
        // - National Vulnerability Database (NVD)
        // - GitHub Security Advisories
        // - Package manager specific databases
        // - OSV (Open Source Vulnerabilities)
        
        // For now, we'll add some sample vulnerabilities
        self.add_sample_vulnerabilities();
        
        Ok(())
    }

    /// Add sample vulnerabilities for testing
    fn add_sample_vulnerabilities(&mut self) {
        // Sample npm vulnerability
        self.vuln_cache.insert(
            "lodash".to_string(),
            vec![Vulnerability {
                cve_id: "CVE-2020-8203".to_string(),
                package_name: "lodash".to_string(),
                affected_version: "<4.17.19".to_string(),
                severity: "HIGH".to_string(),
                description: "Prototype pollution vulnerability".to_string(),
                fixed_version: Some("4.17.19".to_string()),
                cvss_score: Some(7.4),
                source: "npm audit".to_string(),
                references: vec![
                    "https://nvd.nist.gov/vuln/detail/CVE-2020-8203".to_string()
                ],
            }]
        );

        // Sample cargo vulnerability
        self.vuln_cache.insert(
            "serde".to_string(),
            vec![Vulnerability {
                cve_id: "RUSTSEC-2023-0001".to_string(),
                package_name: "serde".to_string(),
                affected_version: "<1.0.152".to_string(),
                severity: "MEDIUM".to_string(),
                description: "Deserialization vulnerability".to_string(),
                fixed_version: Some("1.0.152".to_string()),
                cvss_score: Some(5.3),
                source: "cargo audit".to_string(),
                references: vec![
                    "https://rustsec.org/advisories/RUSTSEC-2023-0001.html".to_string()
                ],
            }]
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_vulnerability_scanner_creation() {
        let scanner = VulnerabilityScanner::new().await.unwrap();
        assert!(!scanner.vuln_cache.is_empty());
    }

    #[test]
    fn test_severity_threshold() {
        let scanner = VulnerabilityScanner {
            vuln_cache: HashMap::new(),
            config: ScannerConfig {
                min_severity: "HIGH".to_string(),
                ..Default::default()
            },
        };

        assert!(!scanner.meets_severity_threshold("LOW"));
        assert!(!scanner.meets_severity_threshold("MEDIUM"));
        assert!(scanner.meets_severity_threshold("HIGH"));
        assert!(scanner.meets_severity_threshold("CRITICAL"));
    }

    #[test]
    fn test_version_matching() {
        let scanner = VulnerabilityScanner {
            vuln_cache: HashMap::new(),
            config: ScannerConfig::default(),
        };

        assert!(scanner.version_matches("1.0.0", "*"));
        assert!(scanner.version_matches("1.0.0", "1.0.0"));
        assert!(!scanner.version_matches("1.0.0", "2.0.0"));
    }
}